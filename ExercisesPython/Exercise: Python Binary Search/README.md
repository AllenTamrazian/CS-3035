<div class="description user_content enhanced" data-resource-type="assignment.body" data-resource-id="1749136"><p>First, if you don't know about or don't remember the Java interface Comparable, read about it here: <a href="https://www.w3schools.blog/comparable-interface-in-java" target="_blank" class="external" rel="noreferrer noopener"><span>https://www.w3schools.blog/comparable-interface-in-java</span><span class="external_link_icon" style="margin-inline-start: 5px; display: inline-block; text-indent: initial; " role="presentation"><svg viewBox="0 0 1920 1920" xmlns="http://www.w3.org/2000/svg" style="width: 1em; height: 1em; vertical-align: middle; fill: currentcolor; --noir-inline-fill: currentcolor;" data-noir-inline-fill="">
    <path d="M1226.667 267c88.213 0 160 71.787 160 160v426.667H1280v-160H106.667v800C106.667 1523 130.56 1547 160 1547h1066.667c29.44 0 53.333-24 53.333-53.333v-213.334h106.667v213.334c0 88.213-71.787 160-160 160H160c-88.213 0-160-71.787-160-160V427c0-88.213 71.787-160 160-160Zm357.706 442.293 320 320c20.8 20.8 20.8 54.614 0 75.414l-320 320-75.413-75.414 228.907-228.906H906.613V1013.72h831.254L1508.96 784.707l75.413-75.414Zm-357.706-335.626H160c-29.44 0-53.333 24-53.333 53.333v160H1280V427c0-29.333-23.893-53.333-53.333-53.333Z" fill-rule="evenodd"></path>
</svg>
<span class="screenreader-only">Links to an external site.</span></span></a> .&nbsp; This source oddly uses the notation +ve to mean "positive" and -ve to mean "negative."</p>
<p>The following Java code implements iterative binary search of a generic List of any reference type that is Comparable to itself (ie, and type T that implements Comparable&lt;T&gt; or extends a type that is Comparable to itself.)&nbsp; If the key (the value we are looking for) is found, the method returns the index at which it was found.&nbsp; If the value is not found, the method returns -1 (a <em>sentinel</em> value, since -1 is not a possible list index) :</p>
<p>public static &lt;T extends Comparable&lt;T&gt;&gt; int iterativeBinarySearch(List&lt;T&gt; list, T key) {<br>&nbsp; &nbsp; &nbsp; &nbsp; if(list.size() &lt; 1) return -1;<br>&nbsp; &nbsp; &nbsp; &nbsp; int low = 0;<br>&nbsp; &nbsp; &nbsp; &nbsp; int high = list.size() - 1;<br>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println("Searching " + list + " for " + key);<br>&nbsp; &nbsp; &nbsp; &nbsp; while (low &lt;= high) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println("Comparing " + key + " and " +list.get(high));<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int mid = (low + high) / 2;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (list.get(mid).equals(key))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return mid;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (list.get(mid).compareTo(key) &lt; 0) // key is later in the sort order than the value at mid<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + 1;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid - 1;<br>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return -1;<br>&nbsp; &nbsp; }</p>
<p>&nbsp;</p>
<p>Write a function that implements the same algorithm in Python.&nbsp; You do not need to write the function in a class, so there is no need to worry about the fact that my method is static.</p>
<p>Write a main() that tests the method for several different cases.&nbsp; In your testing, remember that binary search requires a data structure (an Array List in this case) that is sorted.&nbsp; You do not need to write sort code; you can test with lists that are hard coded in already-sorted order.</p>
<p>Turn in your code and a screenshot or copy/paste of the output from running your main()</p>
<p>&nbsp;</p></div>
